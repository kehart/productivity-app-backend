package	managers

import (
	"github.com/productivity-app-backend/src/utils"
	"github.com/stretchr/testify/mock"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"testing"
)

func TestInsertEvent(t *testing.T) {

}

func TestGetEvents(t *testing.T) {

}

func TestGetSingleEvent(t *testing.T) {
	db := new(fakeStore)
	id := primitive.ObjectID{}
	u := utils.User{
		FirstName: "Bruce",
		LastName:  "Lee",
		ID:        id,
	}

	db.On("FindByID", id).Return(u, nil)

}

/*db := new(fakeStore)
	p := post{
		ID:      12,
		Title:   "me",
		Slug:    "oops-oops",
		Content: "Used to be human",
	}

	db.On("FindByID", 12).Return(p, nil)

	defer db.AssertExpectations(t)

	a := &app{db}

	r, _ := http.NewRequest(http.MethodGet, "/posts/view/12", strings.NewReader(""))

	rr := httptest.NewRecorder()

	http.HandlerFunc(viewPost(a)).ServeHTTP(rr, r)

	if got := rr.Code; got != http.StatusOK {
		t.Fatalf(`Invalid status code.. Expected %d \n Got %d`, http.StatusOK, got)
	}*/

// fakeStore is an autogenerated mock type for the fakeStore type
//generated by the mockery tool
type fakeStore struct {
	mock.Mock
}

// What Called returns depends on what you pass to return in the call "db.On("FindByID", id).Return(u, nil)"

// Create provides a mock function with given fields: p
func (_m *fakeStore) Create(user *utils.User) error {
	ret := _m.Called(user)

	var r0 error
	if rf, ok := ret.Get(0).(func(*utils.User) error); ok {
		r0 = rf(user)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: ID
func (_m *fakeStore) Delete(ID int) error {
	ret := _m.Called(ID)

	var r0 error
	if rf, ok := ret.Get(0).(func(int) error); ok {
		r0 = rf(ID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FindByID provides a mock function with given fields: ID
// FindById(id primitive.ObjectID, user *User) error
// TODO make the function return a user instead of modifying a pointer
func (_m *fakeStore) FindByID(ID int) (utils.User, error) {
	ret := _m.Called(ID)

	var r0 utils.User
	if rf, ok := ret.Get(0).(func(int) utils.User); ok {
		r0 = rf(ID)
	} else {
		r0 = ret.Get(0).(utils.User)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(ID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TODO
/*
- change DB functions to return values instead of modifying args
- test that this doesnt break anything
- change signatures in this module to match interface
- complete the mock functions
- write the test functions
 FOR THE HANDLERS
- create an interface for the manager
- create concrete implementation for the manager
- create mock implementation
- write handler functions
 */